ЛАВНАЯ

- [ВВЕДЕНИЕ](#введение)

- [НАЧАЛО РАБОТЫ](#начало-работы)
  - [ОБЫЧНЫЙ ПОЛЬЗОВАТЕЛЬ](#начало-работы-как-обычный-пользователь)
  - [РАЗРАБОТЧИК](#начало-работы-как-разработчик-проектов)
  - [ПРОДАВЕЦ и РЕСЕЛЛЕР (Использование CLI)](#начало-работы-как-продавец-проектов-или-реселлер-minibot)

- [РУКОВОДСТВО ПО РАЗРАБОТКЕ](#руководство-по-разработке)
  - [КОНЦЕПЦИИ ФРЕЙМВОРКА](#концепции-фреймворка)
    - [ПРОЕКТ](#проект)
    - [ГРУППА ПУТЕЙ](#группа-путей)
    - [СЛЕДУЮЩАЯ ГРУППА ПУТЕЙ](#следующая-группа-путей)
    - [ПУТЬ](#путь)
    - [ПУТЬ К ТРУПУ](#путь-к-трупу)
    - [ТОЧКА МАРШРУТА](#точка-маршрута)
    - [РАНДЕВУ](#рандеву)
    - [ДЕЙСТВИЕ ТОЧКИ МАРШРУТА](#действие-точки-маршрута)
    - [ОБЩЕЕ СВОЙСТВО](#общее-свойство)
    - [ГЛОБАЛЬНОЕ ДЕЙСТВИЕ](#глобальное-действие)
    - [УСЛОВИЕ и ПЕРЕМЕННАЯ](#условие-и-переменная)
    - [ПОЛЬЗОВАТЕЛЬСКИЙ СКРИПТ](#пользовательский-скрипт)
    - [СОСТОЯНИЯ НАВИГАЦИИ](#состояния-навигации)
    - [СЛОВАРЬ ФРЕЙМВОРКА](#словарь-фреймворка)
  - [ВАШ ПЕРВЫЙ ПРОСТОЙ ПРОЕКТ ФАРМА](#ваш-первый-простой-проект-фарма)
    - [ЗАПУСК MINIBOT STUDIO](#запуск-minibot-studio)
    - [СОЗДАНИЕ НОВОГО ПРОЕКТА](#создание-нового-проекта)
    - [ПРОЕКТИРОВАНИЕ ТОПОЛОГИИ ПРОЕКТА](#проектирование-топологии-проекта)
    - [СОЗДАНИЕ ГРУПП ПУТЕЙ](#создание-групп-путей)
    - [ЗАПИСЬ ПУТЕЙ](#запись-путей)
    - [НАЗНАЧЕНИЕ ПУТЕЙ К ГРУППАМ ПУТЕЙ](#назначение-путей-к-группам-путей)
    - [НАСТРОЙКА РАНДЕВУ](#настройка-рандеву)
    - [ДОБАВЛЕНИЕ ОБЩИХ СВОЙСТВ](#добавление-общих-свойств)
    - [ДОБАВЛЕНИЕ ДЕЙСТВИЙ ТОЧЕК МАРШРУТА](#добавление-действий-точек-маршрута)
    - [ФИНАЛИЗАЦИЯ И ПУБЛИКАЦИЯ](#финализация-и-публикация)
  - [СОЗДАНИЕ СОБСТВЕННОГО ФРЕЙМВОРКА И АДДОНА](#создание-собственного-фреймворка-и-аддона)
    - [РАЗБЛОКИРОВКА ЗАЩИЩЕННОГО WOW API](#разблокировка-защищенного-wow-api)
    - [УНИВЕРСАЛЬНЫЙ ID ОБЪЕКТА](#универсальный-id-объекта)
    - [ПОЛЬЗОВАТЕЛЬСКИЙ API](#пользовательский-api)
    - [ПРОЕКТ НЕЗАВИСИМЫЙ ОТ ФРЕЙМВОРКА](#проект-независимый-от-фреймворка)
-----------------------------

# ВВЕДЕНИЕ

**MiniBot для WoW** - это простая в использовании, продвинутая, универсальная платформа на основе подписки для разработки, выпуска и запуска проектов ботов для WoW. Она предоставляет множество революционных функций, и вам не нужно ничего другого, чтобы воплотить всю магию ботов в реальность!

Весь **MiniBot** имеет множество инновационных функций. Назовем лишь некоторые из них - мы выделим здесь только самые важные и революционные, а также в [ПРОМО ВИДЕО](https://www.youtube.com/watch?v=_n1Dtu_zdaQ).

## Проприетарное Ядро

Нет, мы не пиксельный бот (доказано, что они нестабильны, низкого качества и даже не на 100% безопасны). Да, мы едим свой собственный обед, используя наше собственное ядро на основе памяти. Оно работает в режиме ядра Windows, используя технологию виртуализации (кольцо -1), в то время как Warden (античит WoW) работает только в пользовательском режиме Windows (кольцо 3). Это как V16, самый мощный двигатель автомобиля на земле.

## Поддержка Двух Версий

**MiniBot** поддерживает как Retail, так и Classic версии WoW (только официальные серверы).

## Официальный Фреймворк на Основе Lua

Существующие "разблокировщики WoW" на рынке предоставляют только голый движок и позволяют сторонним разработчикам писать Lua аддоны с нуля. Такие разработчики имеют очень мало знаний о том, как работают разблокировщики под капотом. Мы считаем, что это неправильно, поскольку это приводит к высокой стоимости разработки, большой фрагментации, ненадежности и, что самое важное, отсутствию безопасности. Кроме того, конечные пользователи могут легко столкнуться с проблемами перекладывания ответственности при такой структуре.

Таким образом, помимо нашего собственного ядра, MiniBot также предоставляет хорошо инкапсулированный фреймворк, разработанный той же командой, которая изобрела ядро. Он устанавливает стандарты разработки ботов для WoW в следующих аспектах.

## На Основе Navmesh
Очевидно, что фреймворк основан на Navmesh для достижения наиболее человекоподобной навигации. Кроме того, он никогда не использует Click-To-Move (печально известный желтый круг на земле), но симулирует каждое действие движения так, как обычно играют 99% пользователей через клавиатуру.

## Разработка Ботов Без Кода

**MiniBot** устраняет необходимость кодирования на Lua, если вы хотите создать обычный продукт бота, предоставляя инструмент на основе GUI под названием "MiniBot Studio". Да, вам нужно иметь только структурированную идею на основе временной шкалы в голове без каких-либо навыков программирования, как при режиссуре фильма! Затем вы можете создать свои собственные высоко настраиваемые проекты ботов в течение пары часов, как при использовании Excel или Adobe Premiere.

## Программируемые Расширения

Хотя вам не нужно кодировать на Lua, вы все еще можете это делать, если хотите настроить вещи, не предоставленные официальным словарем. Фреймворк дает вам несколько точек расширения, где вы можете писать свои собственные Lua скрипты. Такой дизайн все еще дает вам большую гибкость в настройке того, что вы хотите.

Если вы все еще не удовлетворены точками расширения фреймворка, вы можете даже создать свой собственный новый Lua фреймворк, как это могут делать ТОЛЬКО другие разблокировщики, при этом он все еще может быть коммерчески защищен следующей функцией.

## Коммерчески Готовые Проекты

**MiniBot** ставит коммерциализацию разработки проектов ботов в высший приоритет. Поэтому он позволяет вам создавать зашифрованные копии вашего собственного проекта с полным контролем авторизации с помощью простого инструмента командной строки. Отправляя только такие защищенные копии другим пользователям, вы можете быть уверены, что ваша собственная проектная работа полностью защищена авторским правом и коммерчески готова.

## Дружелюбность к OEM

Хотя **MiniBot** является платной платформой, мы все еще дружелюбны к OEM (также известному как белая маркировка). Вы можете легко создать свой собственный бренд на основе технологии **MiniBot**. CLI версия (командная строка) **MiniBot** дает вам одну командную строку (CLI) для создания OEM версии **MiniBot** в течение пары минут!

Кроме того, поскольку **MiniBot CLI** может запускаться в "тихом режиме", вы также можете выбрать сложный, но более настраиваемый способ создания OEM, создав свое собственное программное обеспечение.

## Низкая Стоимость

Укрепленное ядро с революционным фреймворком требует лишь небольшого пожертвования для подписки. Не забывайте, что вам нужно подписаться только один раз в одном месте, и вы получите все необходимое! Мы просим только ежемесячные подписки максимум. И если вы только случайные пользователи, пробные версии также доступны **БЕСПЛАТНО** (ограниченное время на данный момент). Более того, поддержка двух версий включена в одну подписку, поэтому вам не нужно подписываться дополнительно на Retail и Classic версии отдельно!

[Вернуться к началу](#главная)

# НАЧАЛО РАБОТЫ

В этом разделе мы кратко проведем вас в мир MiniBot.

## Начало Работы как Обычный Пользователь

Как обычному пользователю бота, шаги для начала работы займут пару минут.

- Из-за технологии ядра убедитесь, что вы используете одну из следующих совместимых ОС Windows.
  - Windows 7 SP1 с последним патчем (6.1.7600.24384 или выше)
  - Windows 8.1 с последним патчем (6.3.9600.19678 или выше)
  - Windows 10 с последним патчем (1809 или выше)

  <img src="images/windows-version.png" width="300" />

- Убедитесь, что ваш ПК соответствует минимальным аппаратным требованиям.
  - Для пользователей Intel ваш процессор должен быть Core Ivy Bridge (3-е поколение) или новее.
  - Для пользователей AMD ваш процессор должен быть серии Ryzen.

- Убедитесь, что виртуализация правильно включена в настройках BIOS вашего ПК, проверено с помощью [Leomoon CPU-V](https://leomoon.com/downloads/desktop-apps/leomoon-cpu-v/).

- Убедитесь, что НЕ запущено защитное программное обеспечение, включая антивирус, такой как Windows Defender, и другие платформы античита, такие как FaceIt и Vanguard.

- Скачайте последнюю GUI версию **MiniBot** (`MiniBot.WoW.zip`) в [Релизах](https://github.com/pierre-picard/minibot-wow/releases/latest).

- Скачайте последний пакет карт (`MiniBot.Maps.zip`) в [Релизах](https://github.com/pierre-picard/minibot-wow/releases/latest) и извлеките его в главную папку **MiniBot** (подпапка `/maps`).

- Запустите **MiniBot**, зарегистрируйте нового пользователя и войдите в систему. (Обратите внимание, что вы можете войти только на один ПК одновременно, поэтому второй вход приведет к аннулированию предыдущих игровых сессий)

  <img src="images/gui-login.png" width="300" />

- Подпишитесь на **MiniBot** с картой пополнения правильного значения, соответствующего выбранной вами опции.

  <img src="images/gui-subscribe.png" width="300" />

- Возьмите один или несколько проектов **MiniBot** (заканчивающихся файлами .bot) и поместите их в подпапку `/scripts`.

  <img src="images/scripts.png" />

- Настройте параметры запуска, запустите систему и войдите в WoW (обратите внимание, что вы можете запустить только одну из двух версий WoW одновременно). Если у вас есть ошибки при запуске, обратитесь к [странице устранения неполадок](https://www.minibot.top/topic/29/troubleshooting-errors-on-minibot-start-up).

  <img src="images/gui-launch.png" width="300" />

- Если все идет правильно, вы должны увидеть внутриигровую панель **MiniBot**. Выберите текущий проект, который вы хотите запустить, и нажмите кнопку `Start`. Не забудьте следовать другим инструкциям разработчика проекта и удачного ботинга!

  <img src="images/game-panel.png" width="300" />
  
[Вернуться к началу](#главная)

## Начало Работы как Разработчик Проектов

Если вы хотите использовать MiniBot AddOn Framework для разработки проекта, который является "без кода", следуйте следующим шагам. В противном случае, если вы приходите со своими собственными чистыми Lua скриптами/аддонами, вы можете перейти к [СОЗДАНИЕ СОБСТВЕННОГО ФРЕЙМВОРКА И АДДОНА](#создание-собственного-фреймворка-и-аддона).

- Скачайте последний `MiniBot Studio` (`MiniBot.Studio.zip`) в [Релизах](https://github.com/pierre-picard/minibot-wow/releases/latest).

- Убедитесь, что у вас установлена последняя версия .NET Framework. Если нет, скачайте ее с сайта [Microsoft](https://dotnet.microsoft.com/download/dotnet-framework).

- Запустите `MiniBot Studio` и выберите базовую папку (обычно `MiniBot\scripts`), которая хранит ваши проекты для разработки. Каждый проект будет подпапкой в ней.

  <img src="images/studio-splash.png" width="500" />

- Создайте новый проект или загрузите существующий из меню.

  <img src="images/studio-project.png" width="800" />

- Запустите **MiniBot** и переключитесь на текущий разрабатываемый проект, затем запишите новые пути.

- Перезапустите `MiniBot Studio`, когда закончите запись новых путей, чтобы использовать их для разработки проекта.

- Обратитесь к нашему [Руководству по разработке](#руководство-по-разработке) для всех основ разработки проекта MiniBot.

[Вернуться к началу](#главная)

## Начало Работы как Продавец Проектов или Реселлер MiniBot

Если вы хотите продавать свою проектную работу или даже хотите создать белую маркировку продукта для ведения собственного бизнеса, добро пожаловать в использование `MiniBot CLI`.

- Скачайте последнюю CLI версию **MiniBot** (`MiniBot.WoW.CLI.zip`) в [Релизах](https://github.com/pierre-picard/minibot-wow/releases/latest).

- Скачайте последний пакет карт (`MiniBot.Maps.zip`) в [Релизах](https://github.com/pierre-picard/minibot-wow/releases/latest) и извлеките его в главную папку **MiniBot** (подпапка `/maps`).

- Введите команду `MiniBot.WoW.Cli.exe -h` для просмотра всех глаголов командной строки MiniBot.

- Вы можете использовать команду `MiniBot.WoW.Cli.exe inject` для запуска системы за один раз. CLI программа укажет результат инъекции через код выхода процесса (0 для успеха и не-0 для кодов ошибок). Примеры приведены ниже.

```bat
REM Показать подробную справку по команде.
MiniBot.WoW.Cli.exe inject -h

REM Запустить WoW (retail) с AddOns Framework, но запустить WoW вручную после.
MiniBot.WoW.Cli.exe inject -u "your@email.com" -p "yourPassword" -g "C:\Games\World of Warcraft\_retail_\Wow.exe" -d "wmb" -s "1"

REM Запустить WoW (classic) без AddOns Framework и запустить WoW после.
MiniBot.WoW.Cli.exe inject -u "your@email.com" -p "yourPassword" -g "C:\Games\World of Warcraft\_classic_\WowClassic.exe" -o -s "1" -l
```

- Вы можете использовать команду `MiniBot.WoW.Cli.exe encrypt` для шифрования исходного кода проекта со встроенными авторизациями и отправки защищенной копии вашим конечным пользователям.
  - Вы можете дополнительно использовать файл определения [auth.json](cli/auth.json), который содержит информацию об авторизации с дополнительной командой [-a path]
  - Примеры приведены ниже.

```bat
REM Показать подробную справку по команде.
MiniBot.WoW.Cli.exe encrypt -h

REM Зашифровать проект "Simple Grind".
MiniBot.WoW.Cli.exe encrypt -u "your@email.com" -p "yourPassword" -g "C:\Games\World of Warcraft\_classic_\WowClassic.exe" -s "C:\MiniBot\scripts\simple-grind" -a "C:\MiniBot\auth.json" -t "C:\MiniBot\scripts"
```

- Вы можете использовать команду `MiniBot.WoW.Cli.exe oem` для создания OEM файла (`product.dat`) для замены оригинального файла.
  - Такая команда требует доступа Дилера, предоставленного вашей учетной записи MiniBot. Свяжитесь с нами для запроса доступа.
  - Такая команда нуждается в файле определения [oem.json](cli/oem.json), который описывает информацию OEM.

[Вернуться к началу](#главная)

# РУКОВОДСТВО ПО РАЗРАБОТКЕ

В этой главе мы проведем вас через все основы разработки проекта MiniBot под его фреймворком.

## КОНЦЕПЦИИ ФРЕЙМВОРКА

В качестве начала разработки ботов для WoW под фреймворком MiniBot, здесь перечислены все основные строительные блоки/концепции. Это необходимо, прежде чем вы сможете начать играть с MiniBot Studio и внутриигровой панелью. Не чувствуйте себя подавленными абстрактными концепциями, потому что вы получите все примеры применения, объясненные в последующих разделах главы.

### ПРОЕКТ

`Проект` - это высшая организационная единица бота. В любое время сессии WoW вы можете выбрать только один запущенный проект. Перед созданием нового проекта бота вам нужно указать базовую папку, содержащую проект, расположенную по умолчанию в `MiniBot\scripts` и настраиваемую на внутриигровой панели. Затем в базовой папке создается подпапка проекта, содержащая все исходные файлы проекта. Обратите внимание, что имя подпапки также является именем проекта, показанным как на внутриигровой панели, так и в MiniBot Studio.

`Проект` следует иерархической структуре (дерево), состоящей из нескольких [Групп путей](#группа-путей) и [Пользовательских скриптов](#пользовательский-скрипт). Следующие разделы покроют и то, и другое вместе с их собственными подразделениями.

[Вернуться к началу](#главная)

### ГРУППА ПУТЕЙ

`Группа путей` - это контейнер навигационных [Путей](#путь). Практически разработчики должны организовать пути, которые служат одной цели или физически находятся в одной зоне, в одну `Группу путей`.

Думайте о запуске проекта MiniBot как об интерактивном фильме, в котором персонаж всегда бежит по одному и только одному пути в группе путей. Как разработчик проекта, вы как режиссер фильма, записывающий пути как сцены, а затем организующий их в группы путей с последующей постобработкой сегментов пути ([Точки маршрута](#точка-маршрута)).

Единственное небольшое отличие здесь в том, что вам нужно создать `Группу путей` в `MiniBot Studio` сначала, прежде чем вы сможете записать [Пути](#путь). Просто щелкните правой кнопкой мыши узел `Path Groups` под корневым узлом `Project` и выберите `Create Path Group`. Затем вернитесь в WoW и введите `/reload`, чтобы увидеть обновленные группы путей в категории "State".

<img src="images/studio-create-path-group.png" width="400" />
<img src="images/game-path-group.png" width="600" />

При первом запуске движок MiniBot Framework выбирает первую [Группу путей](#группа-путей), перечисленную в [Проекте](#проект). Вы также можете изменить текущую [Группу путей](#группа-путей), настроив `Path Group`, показанную выше. Затем всегда первый [Путь](#путь) [Группы путей](#группа-путей) выбирается как текущий, по которому будет бежать персонаж.

[Вернуться к началу](#главная)

### СЛЕДУЮЩАЯ ГРУППА ПУТЕЙ

При завершении любого [Пути](#путь) в [Группе путей](#группа-путей), Фреймворк будет смотреть на группу `Следующих групп путей` текущей [Группы путей](#группа-путей), которые определяют переходы к другим [Группам путей](#группа-путей). Если условие любой `Следующей группы путей` выполнено, соответствующая [Группа путей](#группа-путей) будет переключена как текущая.

Такой переход может дополнительно включать "переходный путь", который ведет к следующей [Группе путей](#группа-путей). Чтобы добавить `Следующую группу путей`, просто щелкните правой кнопкой мыши `Next Path Groups` под конкретным узлом [Группы путей](#группа-путей) и выберите `Create Next Path Group`.

<img src="images/studio-create-next-path-group.png" width="700" />

[Вернуться к началу](#главная)

### ПУТЬ

`Путь` - это виртуальная единица, содержащая последовательность [Точек маршрута](#точка-маршрута). По умолчанию персонаж бежит от первой точки маршрута к последней, где путь "завершается". По умолчанию движение персонажа между точками маршрута или любыми целями основано на **умной навигации Navmesh**. Вы можете вручную отключить это, добавив [Общие свойства](#общее-свойство) `is_direct` или когда пакеты карт не загружены правильно.

Вся логика навигации была частично обсуждена в вышеуказанных разделах, но мы суммируем их здесь, как показано ниже.

- Когда бот запущен, текущая [Группа путей](#группа-путей) подтверждается согласно конфигурациям "State" на панели.
- Первый `Путь` в текущей [Группе путей](#группа-путей) выбирается как текущий, по которому бежит персонаж.
- Когда текущий `Путь` завершен, проверяется каждая [Следующая группа путей](#следующая-группа-путей), определенная в текущей [Группе путей](#группа-путей).
- Если любая из них проходит проверку:
  - Если определен "переходный путь", он будет выбран как текущий [Путь](#путь).
  - В противном случае или если "переходный путь" завершен, текущая [Группа путей](#группа-путей) переключается на ту, которая определена в [Следующей группе путей](#следующая-группа-путей), и текущий `Путь` изменяется на первый `Путь` новой [Группы путей](#группа-путей).
- Если ни одна не проходит проверку:
  - Случайный путь в текущей [Группе путей](#группа-путей) выбирается как текущий, по которому бежит персонаж.

Чтобы создать путь, вам нужно переключиться в WoW и создать соответствующие макросы записи, перечисленные в нижней части панели (категория `Recording`). Дальнейшее практическое руководство по записи путей будет дано в последующих главах. Когда пути записаны, вам нужно перезапустить `MiniBot Studio`, чтобы подготовить их для дальнейшего редактирования проекта.

Вы можете добавить недавно записанный `Путь` в [Группу путей](#группа-путей), щелкнув правой кнопкой мыши "Paths - Add Path". Дальнейшие изменения существующих путей могут быть полностью выполнены без внутриигровых операций, просто нажав меню `Paths` и выбрав путь, который вы хотите редактировать.

<img src="images/studio-path.png" width="600" />

[Вернуться к началу](#главная)

### ПУТЬ К ТРУПУ

Фреймворк позволяет вам определить обработку смерти в терминах указания дополнительного пути для получения вашего трупа. Когда указан `Путь к трупу`, дух будет освобожден сначала, а затем будет бежать по `Пути к трупу`. Позиция трупа будет добавлена в конец пути динамически фреймворком, чтобы обеспечить достижение трупа. Считайте это "вспомогательным путем" для получения трупа, чтобы избежать застревания. Если такой путь не указан, персонаж будет напрямую навигировать к трупу.

Обратите внимание, что навигация к трупу является "подпроцессом" обычной навигации. Она запускается в любое время, когда персонаж умирает, и не будет мешать общим состояниям навигации. Иногда позиция трупа не существует или непредсказуема. Но не волнуйтесь, фреймворк автоматически завершит подпроцесс, когда персонаж станет живым каким-либо образом (например, в подземельях или на полях боя).

Вы можете указать `Путь к трупу` на любой детализации ([Группа путей](#группа-путей), [Путь](#путь) или [Точка маршрута](#точка-маршрута)) через его [Общее свойство](#общее-свойство). Больше примеров будет дано в следующих главах.

[Вернуться к началу](#главная)

### ТОЧКА МАРШРУТА

`Точка маршрута` - это атомарная навигационная единица [Проекта](#проект). Когда персонаж движется по [Пути](#путь) в [Группе путей](#группа-путей), он по сути идет от одной мировой позиции к следующей, также известной как `Точка маршрута`. Как только последняя достигнута, текущий путь завершается, и логика переключения вступает в силу, как обсуждалось выше.

Вы можете изменить точки маршрута после записи пути. Просто перейдите в редактор путей и щелкните правой кнопкой мыши точку маршрута, чтобы вызвать контекстное меню.

<img src="images/studio-waypoint.png" width="600" />

[Вернуться к началу](#главная)

### РАНДЕВУ


Когда вы записываете путь, путевые точки индексируются от 1 до N. Однако, когда путь выполняется, движок Framework добавляет дополнительную путевую точку с индексом 0, называемую Рандеву, которая определена в каждой [Группе путей](#path-group). Другими словами, все [Пути](#path) в одной [Группе путей](#path-group) разделяют общее Рандеву, включая переходные пути во всех [Следующих группах путей](#next-path-group).

Цель Рандеву - обеспечить, чтобы все [Пути](#path) в одной [Группе путей](#path-group) находились близко друг к другу географически. Чтобы указать координаты Рандеву, выберите [Группу путей](#path-group), нажмите "Rendezvous Waypoint", а затем введите значение в правой части.

<img src="images/studio-rendezvous.png" width="600" />

[Вернуться к началу](#home)

### ДЕЙСТВИЕ ПУТЕВОЙ ТОЧКИ

`Действия путевых точек` - это последовательность действий, которые должны быть выполнены при прибытии персонажа в [Путевую точку](#waypoint). Такое действие подобно функции, выполняемой каждый игровой кадр, с возвращаемым булевым значением, указывающим статус завершения. Действие также может иметь группу определенных условий. Если есть хотя бы одно условие и группа условий оценивается как ложная, действие также считается "завершенным" и будет пропущено.

Только когда статус завершен, персонаж перейдет к следующему действию, пока не закончит последнее. И только когда все `Действия путевых точек` завершены, персонаж начнет навигацию к следующей [Путевой точке](#waypoint).

Чтобы добавить `Действие путевой точки`, сначала найдите путевую точку, а затем щелкните правой кнопкой мыши `Actions` под ней. Обратите внимание, что вам нужно следовать синтаксису "вызова функции" для описания действия. Framework предоставил множество встроенных действий, которые можно найти в [Словаре Framework](#framework-vocabulary). И наконец, вы также можете программно расширить свои пользовательские действия, написанные на Lua.

<img src="images/studio-waypoint-action.png" width="600" />

[Вернуться к началу](#home)

### ОБЩЕЕ СВОЙСТВО

`Общие свойства` - это "общие" пары ключ-значение, применимые ко всем уровням детализации навигации ([Группа путей](#path-group), [Путь](#path) и [Путевая точка](#waypoint)), определяющие аспект поведения персонажа, пока персонаж движется к [Путевой точке](#waypoint) (Следующая путевая точка) с ним, в терминах движения, боя, взаимодействия, восстановления и т.д. Важной особенностью о них является "наследование". То есть `Общие свойства`, определенные на более высоких уровнях, применяются ко всем внутренним нижним областям. Это также означает, что вы можете переопределить то же свойство (с тем же именем) в этих внутренних нижних областях, чтобы переопределить унаследованные значения свойств.

Например, если вы определите свойство "A" со значением "a" в [Группе путей](#path-group), все ее [Пути](#path) и [Путевые точки](#waypoint) также получат его. Таким образом, вы избавляете себя от необходимости определять свойства для каждой [Путевой точки](#waypoint) по одной. Между тем, если вы определите то же свойство "A" с другим значением "b" на одной из внутренних [Путевых точек](#waypoint), оно переопределит унаследованное значение "a" от родителя для этой [Путевой точки](#waypoint).

Чтобы определить `Общее свойство`, сначала выберите навигационную единицу, а затем щелкните правой кнопкой мыши `Common Properties` под ней. Framework предоставил множество встроенных `Общих свойств`, которые можно найти в [Словаре Framework](#framework-vocabulary). В отличие от действий, вы не можете расширить `Общие свойства` программно, поскольку они тесно переплетены с framework.

<img src="images/studio-common-property.png" width="600" />

[Вернуться к началу](#home)

### ГЛОБАЛЬНОЕ ДЕЙСТВИЕ

Особое [Общее свойство](#common-property) стоит упомянуть отдельно здесь: `Глобальное действие`. Подобно [Действию путевой точки](#waypoint-action), это просто другой тип действия, выполняемого в любое время в рамках области применения [Общего свойства](#common-property), с опционально определенными условиями. Разница в том, что `Глобальные действия` оцениваются и выполняются в каждом кадре перед другими поведениями. И если условия проверяются, персонаж приостановит другие нормальные поведения, переопределенные выполнением `Глобального действия`.

[Вернуться к началу](#home)

### УСЛОВИЕ и ПЕРЕМЕННАЯ

Вы видели `Условие` несколько раз, включая для [Следующей группы путей](#next-path-group), [Действия путевой точки](#waypoint-action) и [Глобального действия](#global-action). По сути, они разделяют одну и ту же синтаксическую структуру Lua/Javascript, состоящую из последовательности простых условных выражений (`<ПЕРЕМЕННАЯ><ОПЕРАТОР><КОНСТАНТА>`), оценивающихся в булевы значения. `Переменная` - это просто строка, которая оценивается Framework в значение. `Оператор` может быть одним из следующих: `> < >= <= = ~=`. `Константа` может быть булевой (`true` или `false`), числом (`1`, `2.3`, `-0.5` и т.д.) или строкой (`"hello"`). Полный пример условного выражения: `myself.health > 10`, оценивающийся как истинный, если процент моего собственного здоровья больше 10%.

`Условия` (также группа условий) - это комбинация множества условных выражений, с `and` или `or` для соединения. Framework также предоставил множество встроенных `Переменных`, которые можно найти в [Словаре Framework](#framework-vocabulary). По сравнению с языками программирования, такими как Lua или Javascript, есть несколько ограничений, таких как ограниченные операторы и поддержка только одного уровня комбинации. Однако это можно легко смягчить, программно расширив ваши пользовательские переменные, написанные на Lua.

[Вернуться к началу](#home)

### ПОЛЬЗОВАТЕЛЬСКИЙ СКРИПТ

Мы сделали "бескодовую" разработку Bot-проекта реальностью, но мы никогда не жертвуем потребностями программирования. Наоборот, мы позволяем программирование скриптов Lua не меньше, чем чистые WoW AddOns. [Проект](#project) может иметь один или несколько прикрепленных `Пользовательских скриптов`, которые по сути являются файлами скриптов Lua, созданными в папке проекта. Файлы скриптов работают очень похоже на обычные файлы скриптов WoW AddOn, загружаемые/выполняемые один раз при загрузке проекта сразу после входа в мир.

Если это все, результат был бы не очень интересным. Фактически, другая основная особенность таких `Пользовательских скриптов` заключается в том, что framework также смотрит на возвращаемое значение каждого файла скрипта. Если это таблица Lua и следует предопределенному синтаксису, framework загрузит `пользовательские действия`, `пользовательские переменные`, `пользовательские настройки` и, что наиболее важно, `пользовательскую ротацию`, необходимую для `pve` и `pvp` [Общих свойств](#common-property) внутри. Пример общей структуры таблицы приведен ниже:

```lua
return {
  -- Определить пользовательские действия.
  actions = {
    ["battle_test"] = function(env, arg)
      print("Это тестовое действие с аргументом:", arg);
      -- Всегда отмечать как завершенное, чтобы убедиться, что действие выполняется только один раз, иначе навигация застрянет здесь :)
      return true;
    end,
    ["battle_leave"] = function(env, arg)
      -- env - это специальная таблица-контейнер с полезными утилитами, одна из которых - "evaluate_variable" для получения значения переменной.
      if (env:evaluate_variable("battleground") == 4) then
        print("Поле боя закончилось!");
        -- Другая утилита - "execute_action" для выполнения действия.
        env:execute_action("leave_battleground");
      else
        print("Поле боя все еще продолжается!");
      end
      return true;
    end
  },
  -- Определить пользовательские переменные.
  variables = {
    ["battle.is_long_enough"] = function(env)
      -- Вы можете использовать синтаксис [setting.xxx] для доступа к текущему значению пользовательской настройки в терминах переменной.
      local battle_timeout = env:evaluate_variable("setting.battle_timeout");
      if (battle_timeout) then
          local battle_duration = env:evaluate_variable("battleground.duration");
          return battle_duration and battle_duration > battle_timeout or false;
      else
          return false;
      end
    end
  },
  -- Определить пользовательские настройки.
  settings = {
    ["battle_timeout"] = {
      -- Имя, отображаемое на панели.
      display_name = "Тайм-аут боя",
      -- Всплывающая подсказка при наведении мыши.
      description = "Настроить тайм-аут каждого боя, в секундах. После того, как продолжительность поля боя превысит значение, покинуть поле боя.",
      -- Имеет ли настройка переключатель.
      can_enable_disable = true,
      -- Состояние переключателя по умолчанию.
      is_enabled_by_default = true,
      -- Тип настройки, может быть "number" или "string".
      type = "number",
      -- Опциональные значения для выпадающего списка (таблица). nil для текстового поля.
      options = nil,
      -- Ширина поля ввода, в пикселях.
      width = 100,
      -- Значение настройки по умолчанию.
      default = 7200,
      -- Ограничение для поля ввода, может быть "percentage", "non_negative_number", "non_negative_integer", "positive_number" или "positive_integer"
      constraint = "non_negative_integer",
    }
  },
  -- Определить ротацию.
  rotations = {
    combat = function(env, is_pulling)
      -- вызывается, когда выбрана целевая единица для атаки.
    end,
    prepare = function(env)
      -- вызывается для проверки и выполнения ротации подготовки, такой как призыв и кормление питомцев, баффы, создание предметов и т.д.
      -- Вернуть true, если подготовка все еще продолжается.
      return false;
    end,
  }
};
```

Обратите внимание, что вам не обязательно возвращать вышеуказанную таблицу как протокол. Таким образом, это ничем не отличается от скрипта AddOn, но он все еще несет преимущества разработки под framework, такие как шифрование и контроль авторизации!

Чтобы добавить `Пользовательский скрипт`, просто разверните узел [Проект](#project) в `MiniBot Studio` и щелкните правой кнопкой мыши `Custom Scripts`. Затем вы можете использовать любой текстовый редактор для редактирования файла скрипта.

<img src="images/studio-custom-script.png" width="600" />

[Вернуться к началу](#home)

### СОСТОЯНИЯ НАВИГАЦИИ

До сих пор мы рассмотрели большинство концепций со стороны дизайна. Однако, когда дело доходит до стороны выполнения, вы увидите категорию `States` на внутриигровой панели, в которой перечислены, поддерживаются и сохраняются все состояния framework. Это идеальный дизайн для сохранения "текущих состояний навигации". Независимо от того, когда вы остановите/выйдете из бота, вы также можете возобновить проект позже с той же точки.

Рассматривайте `Состояния навигации` как мост между разработчиком проекта и пользователем. Пока framework автономно обновляет поля состояния на панели, пользователь также может изменить их для лучшей гибкости перед нажатием `Start`. Это становится довольно удобным, если пользователь хочет сообщить что-то о любой точке проекта с текущими `Состояниями навигации` разработчику проекта. Это также очень полезная зона для разработчиков, чтобы увидеть, как framework работает на лету, для лучшего понимания и усвоения вышеуказанных концепций.

[Вернуться к началу](#home)

### СЛОВАРЬ FRAMEWORK

Актуальный словарь AddOn Framework для поиска официальных [Общих свойств](#common-property), переменных условий и действий поддерживается по адресу:

https://docs.google.com/spreadsheets/d/1dzurAMgAs0RuRevQZHptpJVQYJFBKb9_gyHsLMS-Wuw

[Вернуться к началу](#home)

## ВАШ ПЕРВЫЙ ПРОСТОЙ ПРОЕКТ ГРАЙНДА

Если вы знакомы с вышеуказанными концепциями, пришло время запачкать руки. Если вы все еще в замешательстве по поводу какой-либо концепции, не стесняйтесь прыгать туда-сюда или смотреть [ОБУЧАЮЩЕЕ ВИДЕО](https://www.youtube.com/watch?v=DMv_8M87ndM). В этом разделе мы собираемся построить ваш первый Bot-проект: `ПРОСТОЙ ГРАЙНД`. Цель - фармить мобов и ресурсы в области открытого мира. Кроме того, персонаж также должен быть способен возвращаться в город для продажи и пополнения, чтобы сделать цикл полностью автономным!

### ЗАПУСК MINIBOT STUDIO

Следуйте шагам в [Начать как разработчик проекта](#start-as-a-project-developer), чтобы скачать и открыть `MiniBot Studio`. Рекомендуется выбрать папку `scripts` в качестве базы и нажать "Start Now".

<img src="images/simple-grind-1.png" width="600" />

[Вернуться к началу](#home)

### СОЗДАНИЕ НОВОГО ПРОЕКТА

Для начала выберите "Projects" - "New" и введите "simple-grind" в качестве имени вашего нового проекта для этого примера. Мы будем использовать карту места рождения гномов "Dun Morg" в WoW Classic для завершения примера проекта.

<img src="images/simple-grind-2.png" width="800" />

Это также подходящее время для изучения структуры проекта в `MiniBot Studio`. Убедитесь, что вы выбрали новый проект как текущий ("Projects" - "Current"), и тогда вы должны увидеть древовидную структуру в левой панели. Разверните узлы дерева, и вы должны увидеть соответствующий редактор для каждого узла в правой панели. Также обратите внимание, что любые изменения, которые вы сделали, сохраняются на лету (явное сохранение не требуется), а также регистрируются в нижнем текстовом окне.

<img src="images/simple-grind-3.png" width="800" />

### ПРОЕКТИРОВАНИЕ ТОПОЛОГИИ ПРОЕКТА

Хороший бот для грайнда должен начинаться с четкого дизайна топологии проекта. Цель проекта может быть разделена на грайнд мобов и ресурсов во внешнем мире, и продажу и пополнение в городской области. Итак, вот визуализация топологии проекта.

<img src="images/simple-grind-4.png" width="400" />

Обратите внимание, что красные стрелочные линии представляют [Пути](#path) [Группы путей](#path-group) `grind`, а синие стрелочные представляют [Пути](#path) [Группы путей](#path-group) `replenish`.

[Вернуться к началу](#home)

### СОЗДАНИЕ ГРУПП ПУТЕЙ

С концептуальной топологией в уме, пришло время вернуться к `MiniBot Studio`, чтобы реализовать [Группы путей](#path-group), показанные выше. [Группа путей](#path-group) `grind` должна покрывать "зону грайнда", а [Группа путей](#path-group) `replenish` должна покрывать "городскую зону".

Вы можете повторно использовать существующие по умолчанию [Группы путей](#path-group) из нового проекта или удалить их все навсегда и пересоздать их. Мы возьмем второй подход здесь. Не забудьте нажать "Enter", когда закончите вводить значение в редакторе правой панели. Щелкните правой кнопкой мыши `Path Groups` под узлом проекта и выберите "Create Path Group". Кроме того, определите [Следующую группу путей](#next-path-group) для каждой из них, как показано в вышеуказанной топологии, и у вас должен быть следующий результат.

<img src="images/simple-grind-5.png" width="800" />

До сих пор [Следующие группы путей](#next-path-group) не имеют никаких условий, поэтому первая будет взята безусловно после завершения [Пути](#path) в текущей [Группе путей](#path-group), что нежелательно. Вместо этого нам нужно добавить условия, чтобы указать, что:

- [Группа путей](#path-group) `grind` должна переключиться на `replenish` только когда инвентарь полон или прочность экипировки низкая. Итак, щелкните правой кнопкой мыши "Conditions" под [Следующей группой путей](#next-path-group) `replenish`, добавьте [Условия](#condition-and-variable), как показано ниже.
  
<img src="images/simple-grind-6.png" width="400" />
  
- [Группа путей](#path-group) `replenish` должна переключиться обратно на `grind` безусловно. Поэтому дальнейшая работа здесь не нужна.
  
<img src="images/simple-grind-7.png" width="400" />
  
[Вернуться к началу](#home)
  
### ЗАПИСЬ ПУТЕЙ

Персонаж не будет двигаться с пустыми [Группами путей](#path-group), определенными выше. Давайте создадим пути, записав их сначала в игре. У нас есть следующие пути для записи:

- grind1 & grind2

Два пути грайнда для грайнда мобов и ресурсов. Вы можете добавить больше путей грайнда для лучшей рандомизации!

// ... existing code ...


- replenish

Единственный путь пополнения для продажи и пополнения.

- grind-replenish

Переходный путь для ведения персонажа от рандеву зоны грайнда к рандеву городской зоны. Здесь это не обязательно, но служит примером.

- replenish-grind

То же самое, что и выше, в обратном направлении.

Во-первых, убедитесь, что вы выбрали режим "Development" для Primary Engine внутриигровой панели.

<img src="images/simple-grind-8.png" width="400" />

Во-вторых, создайте следующие макросы разработки, необходимые для записи путей. Чтобы проверить полный список доступных макросов записи и других макросов разработки, перейдите в нижнюю часть панели и проверьте категорию "Dev". Не забудьте запустить бота перед использованием макросов.

<img src="images/simple-grind-9.png" width="400" />

- NEW: `/wmb 1st start_rec grind1 2`
  
Начать новую запись пути в текущем проекте с именем "grind1".
  
<img src="images/simple-grind-10.png" width="400" />
<img src="images/simple-grind-11.png" width="400" />
  
- ADD_WP: `/wmb 1st add_waypoint @player`
  
Добавить путевую точку в местоположении персонажа в конец текущего записываемого пути.
  
<img src="images/simple-grind-12.png" width="400" />
<img src="images/simple-grind-13.png" width="600" />
  
- SAVE: `/wmb 1st stop_rec save`
  
Завершить запись и сохранить путь в файл в папке текущего проекта.

<img src="images/simple-grind-14.png" width="400" />
<img src="images/simple-grind-15.png" width="400" />
  
- CANCEL: `/wmb 1st stop_rec cancel`
  
Отменить запись.

<img src="images/simple-grind-16.png" width="400" />
  
- POS: `/wmb 1st show_position @player`
  
Показать текущую позицию персонажа для копирования-вставки. Это полезно для изменения координат позже, включая [Рандеву](#redezvous).

<img src="images/simple-grind-17.png" width="400" />
<img src="images/simple-grind-18.png" width="400" />

Не забудьте повторить вышеуказанные шаги для записи всех необходимых путей согласно [Топологии](#design-project-topology). И когда все пути записаны, перезапустите `MiniBot Studio`, и вы должны увидеть новые пути в меню "Paths".

<img src="images/simple-grind-19.png" width="400" />
  
[Вернуться к началу](#home)

### НАЗНАЧЕНИЕ ПУТЕЙ ГРУППАМ ПУТЕЙ

На данный момент все записанные пути не имеют владельца. Нам нужно назначить их соответствующим [Группам путей](#path-group) или [Следующим группам путей](#next-path-group).

В `MiniBot Studio` выберите "Paths" под [Группой путей](#path-group) и щелкните правой кнопкой мыши "Add Path", затем введите имя пути для назначения группе. Также проверьте редактор правой панели [Следующей группы путей](#next-path-group) и введите имя пути, чтобы назначить его как переходный. В итоге у вас должна быть следующая структура путей.

<img src="images/simple-grind-20.png" width="400" />

Вы можете просмотреть результат назначения обратно в игре с помощью следующего макроса, чтобы показать все пути в группе путей в игре.

- SHOW_PG: `/wmb 1st show_path_group grind toggle ff0000`

Показать/Скрыть все пути в группе путей "grind" красным цветом, как в [Топологии](#design-project-topology).

<img src="images/simple-grind-21.png" width="400" />
<img src="images/simple-grind-22.png" width="600" />

[Вернуться к началу](#home)

### НАСТРОЙКА РАНДЕВУ

Используйте макрос "POS" для записи рандеву для обеих [Групп путей](#path-group). Скопируйте и вставьте координаты обратно в соответствующую [Группу путей](#path-group) в "MiniBot Studio", как показано ниже.

<img src="images/simple-grind-23.png" width="800" />

До этого момента вы закончили всю работу по записи в игре, визуализированную ниже. Вы даже можете начать тестовую навигацию в игре, и вы увидите, что персонаж будет двигаться по путям, как вы только что записали.

Группа путей "grind":

<img src="images/simple-grind-24.png" width="800" />

Группа путей "replenish":

<img src="images/simple-grind-25.png" width="800" />
  
[Вернуться к началу](#home)

### ДОБАВЛЕНИЕ ОБЩИХ СВОЙСТВ

Для общих поведений, отличных от обычной навигации, таких как бой и лут, вам нужно добавить [Общие свойства](#common-property), включая `pve`, `pvp`, `loot`, `skin`, `herb`, `mine`, `treasure` и `harvest`. Для деталей этих свойств вы можете обратиться к их документации, перечисленной в `MiniBot Studio` или [Словаре Framework](#framework-vocabulary). В этом примере мы рассмотрим только два из них здесь, в то время как остальные следуют аналогичному шаблону.

- `pve` для грайнда мобов

Без [Общего свойства](#common-property) `pve` персонаж не будет вступать в бой с мобами. Просто добавьте его к путям `grind1` и `grind2`, чтобы пока персонаж движется по обоим путям, он искал мобов на лету и убивал их.

Активное боевое поведение (также "атака") является частью 1 `pve`. Используйте его, когда хотите, чтобы персонаж атаковал мобов активным способом. Обратите внимание, что вам нужно указать диапазоны поиска и типы мобов (ID), если необходимо. Для ID мобов вы можете использовать Magic Vision в нашем предоставленном `Secondary Engine` или любые другие ID AddOns, чтобы найти их. Кроме того, вы можете указать диапазон атаки между персонажем и мобом. Это переопределит соответствующую настройку панели пользователя. И наконец, вы также можете указать [Условия](#condition-and-variable) для каждого определения атаки, которые будут оцениваться каждый кадр во время области применения `pve`.

<img src="images/simple-grind-26.png" width="400" />

Пассивное боевое поведение является частью 2 `pve`. Используйте его, когда хотите, чтобы персонаж защищался, если нежелательная агрессия притянута. Вы также можете определить одну или несколько атак, упорядоченных по приоритету.

- Боевая ротация для `pve`

Персонаж все еще не будет вступать в бой с мобом без определенной валидной `Боевой ротации`. Это возможно только через [Пользовательский скрипт](#custom-script). Да, к сожалению, вам нужно писать Lua для этого. Мы не предлагаем никаких предварительно упакованных стандартных логик CR, поскольку они склонны к изменениям и высоко настраиваемы. Однако есть несколько степеней для этого, от легких до более сложных. Мы рассмотрим их здесь.

Независимо от того, какой способ выбрать, первый шаг - создать [Пользовательский скрипт](#custom-script), как показано ниже.

<img src="images/simple-grind-27.png" width="400" />

Затем отредактируйте файл скрипта следующим кодом, который содержит простейшие логики как воин 1-го уровня для убийства моба.

```lua
return {
  -- Определить ротацию.
  rotations = {
    combat = function(env, is_pulling)
      -- вызывается, когда выбрана целевая единица для атаки.
      if (UnitExists("target")) then
        RunMacroText("/startattack");
        if (UnitPower("player") > 15) then
          RunMacroText("/cast Heroic Strike");
        end
      end
    end,
    prepare = function(env)
      -- вызывается для проверки и выполнения ротации подготовки, такой как призыв и кормление питомцев, баффы, создание предметов и т.д.
      -- Вернуть true, если подготовка все еще продолжается.
      return false;
    end,
  }
};
```

Вернитесь в игру (сначала перезагрузите), убедитесь, что вы настроили правильные боевые параметры на панели, включая боевые дистанции! Итак, не так уж и сложно, не так ли?

<img src="images/simple-grind-28.png" width="600" />

Однако это все еще становится утомительным, если вы хотите позаботиться о всех классах и специализациях в WoW, написав чистые коды Lua вручную. Не волнуйтесь, мы предлагаем вам использовать какой-нибудь популярный AddOn ротации, такой как [GSE](https://www.curseforge.com/wow/addons/gse-gnome-sequencer-enhanced-advanced-macros). Таким образом, вы можете просто позволить пользователям создавать макросы в GSE с определенным именем и вызывать этот макрос простым вызовом функции [RunMacro](https://wow.gamepedia.com/API_RunMacro). Поскольку в сети много ресурсов GSE, настройка логик CR - это пустяк.

- `loot` для лута

Вам нужно добавить еще одно [Общее свойство](#common-property) `loot` для лута мертвых мобов. Мы не будем повторять детали здесь, аналогично `pve`, просто как показано ниже.

<img src="images/simple-grind-29.png" width="400" />
<img src="images/simple-grind-30.png" width="600" />

- `skin` для снятия шкур

Снятие шкур с мертвых единиц - это еще одно [Общее свойство](#common-property), аналогичное `loot`. Определите его, если вам нужно, чтобы персонаж снимал шкуры с мобов, если они подходят для снятия шкур. В этом примере мы не будем рассматривать использование здесь.

- `herb`, `mine` и `treasure`

Когда дело доходит до трав, руд и сундуков, framework предоставил эти 3 встроенных [Общих свойства](#common-property) также. По сути, это работает с "Игровыми объектами" через фильтрацию ID моделей. В результате мы поддерживаем только эти 3 свойства в WoW Classic (нет поддержки Retail). Не волнуйтесь, просто используйте `harvest`, если хотите делать эти вещи в WoW Retail. В этом примере мы не будем рассматривать использование здесь.

- `harvest`

Если вы хотите "взаимодействовать и лутать" любые неклассифицированные "Игровые объекты", просто добавьте [Общие свойства](#common-property) `harvest`, которые требуют от вас указания ID моделей. Вы должны использовать это для всех игровых объектов в Retail и других типов игровых объектов в Classic, таких как квестовые цели. В этом примере мы не будем рассматривать использование здесь.

[Вернуться к началу](#home)

### ДОБАВЛЕНИЕ ДЕЙСТВИЙ ПУТЕВЫХ ТОЧЕК

В то время как [Общие свойства](#common-property) обычно описывают "линейные поведения", когда персонаж движется по пути к следующей [Путевой точке](#waypoint), вы можете определить "точечные действия" по прибытии в определенную [Путевую точку](#waypoint). В этом примере это включает "продажу и ремонт" и "покупку припасов" на пути `replenish`.

- Продажа и ремонт

Первое, что мы делаем, когда возвращаемся в город, - это продаем хлам и ремонтируем экипировку. NPC, с которым мы собираемся взаимодействовать для этой работы, находится рядом с [Путевой точкой](#waypoint) #7. Вы можете использовать "Secondary Engine", чтобы получить его ID 1104, и в качестве хорошей заметки мы переименовываем эту [Путевую точку] соответственно как "sell_repair@1104".

<img src="images/simple-grind-31.png" width="300" />

Вернувшись в `MiniBot Studio`, щелкните правой кнопкой мыши "Actions" под [Путевой точкой](#waypoint) #7, добавьте [Действие путевой точки](#waypoint-action) `interact({"id": 1104, "range": 10})`. Это действие будет искать NPC (с ID 1104 в пределах 10 ярдов), подойдет достаточно близко, если найдет, и взаимодействует с ним. Согласно [Словарю Framework](#framework-vocabulary), действие "interact" никогда не вернет true (никогда не завершится), нам нужно добавить предварительное условие для него, чтобы контролировать его завершение. То есть `merchant.is_open = false` (когда окно торговца не открыто). Чтобы резюмировать процедуру здесь, мы можем использовать следующий псевдокод.

```lua
while (action.conditions() == true) do
  if (action() == true) then
    break;
  end
end
```

Как только окно торговца открыто, бот перейдет к следующему действию `sell()`. В этом примере, хотя это действие возвращает true (завершено), когда все предметы проданы, мы все еще добавляем предварительное условие `action.duration < 5` для него. Это главным образом потому, что мы также хотим контролировать тайм-аут такого действия в 5 секунд, чтобы избежать неожиданных задержек. 3-е действие `repair()` также аналогично, за которым следует 4-е действие `close_merchant()` как хорошее поведение, чтобы попрощаться перед уходом.

В итоге у нас должен быть следующий дизайн [Действия путевой точки](#waypoint-action).

<img src="images/simple-grind-32.png" width="300" />

- Покупка припасов

Framework имеет встроенный простой модуль для покупки еды, напитков и боеприпасов (только для Classic). Пользователи могут настроить поведение покупки на панели, в то время как разработчик проекта должен беспокоиться только о взаимодействии с NPC. NPC (ID=829) для этой работы находится рядом с [Путевой точкой](#waypoint) #17, переименованной как "purchase_supplies@829". Сделайте следующий дизайн действия аналогично вышеуказанному, единственное отличие которого - новое действие `replenish()`.

// ... existing code ...


<img src="images/simple-grind-33.png" width="300" />
<img src="images/simple-grind-34.png" width="300" />

[Вернуться к началу](#home)

### ЗАВЕРШЕНИЕ И ПУБЛИКАЦИЯ

Поздравляем! Вы завершили свой первый проект: Simple Grind! Переключите основной переключатель в режим "Navigation" и попробуйте его. Полный исходный код примера проекта можно скачать [здесь](https://github.com/pierre-picard/minibot-wow/tree/master/examples/simple-grind). Вы также можете посмотреть наш предварительно записанный запуск ниже.

[![Посмотреть видео](https://img.youtube.com/vi/nh42ssQU5hs/hqdefault.jpg)](https://youtu.be/nh42ssQU5hs)

Теперь вы наверняка хотите поделиться своей работой над проектом с другими. Это крайне просто. Помните, что проект - это просто одна папка, аналогично WoW AddOn. Так что просто перейдите в папку вашего проекта и отправьте её другому человеку, точно так же, как вы можете скачать пример проекта выше.

Подождите, а что если я не хочу делиться исходным кодом для защиты авторских прав? Не волнуйтесь! как обсуждалось в [Продавец и реселлер](#start-as-a-project-seller-or-minibot-reseller), вы можете использовать `MiniBot CLI` для компиляции исходного кода вашего проекта в зашифрованную копию. Более того, это также позволяет добавить контроль авторизации в скомпилированную копию в терминах никнеймов MiniBot, дат истечения, максимального количества разрешенных сессий и того, скрывать ли детали выполнения от конечного пользователя. В этом разделе мы проведем вас через использование `MiniBot CLI`.

- Скачать `MiniBot CLI`

Перейдите в [Релизы](https://github.com/pierre-picard/minibot-wow/releases/latest) и скачайте `MiniBot.WoW.CLI.zip`. Вы можете просто поместить EXE файл в ту же папку, что и GUI версия, чтобы они могли использовать одну структуру папок.

<img src="images/simple-grind-35.png" width="600" />

- Открыть командную строку и проверить справку

Введите команду


MiniBot.WoW.Cli.exe --help


чтобы увидеть следующие команды. Если вы хотите использовать функцию inject, не забудьте предоставить права администратора.

<img src="images/simple-grind-36.png" width="600" />

Теперь введите команду


Вы должны увидеть параметры для команды `encrypt`.

<img src="images/simple-grind-37.png" width="600" />

- Подготовить авторизации

Вам также нужно подготовить отдельный JSON файл, содержащий авторизации, шаблон которого можно скачать [здесь](cli/auth.json). Вы можете изменить его и добавить больше необходимых авторизаций. Также вы можете опустить любое из 4 измерений авторизации, чтобы создать "неограниченный доступ". В конечном итоге, если это пустой JSON массив, результатом будет зашифрованная, но бесплатная копия.

Наконец, просто поместите отредактированный файл `auth.json` в корневую папку программы.

- Выполнить команду

Теперь введите команду:


MiniBot.WoW.Cli.exe encrypt --username [логин пользователя] --password [пароль] --game-file "C:\Program Files\Battle.net\World of Warcraft_classic_\WowClassic.exe" --source-dir "C:\minibot.wow\scripts\simple-grind" --target-dir "C:\minibot.wow\scripts" --auth-file "C:\minibot.wow\auth.json"


Не забудьте заменить аргументы в соответствии с вашим ПК. Если всё проверяется нормально, вы должны увидеть следующий результат со скомпилированным файлом, сохраненным в целевой папке, который можно опубликовать для других.

<img src="images/simple-grind-38.png" width="600" />

Скомпилированный файл проекта (xxx.bot) ничем не отличается от папки исходного проекта, которая будет загружена в игру рядом. Единственное отличие в том, что вы не можете обновлять скомпилированные файлы проекта в реальном времени, как папки исходного проекта, поэтому вам нужно перезапустить WoW для их обновления.

[Вернуться к началу](#home)

## СОЗДАНИЕ СОБСТВЕННОГО FRAMEWORK И ADDON

Это продвинутая тема для настоящих гуру Lua. На самом деле, это способ и единственный способ, который предоставляют другие "разблокировщики" на рынке. Конечно, мы также не ограничиваем никаких возможностей в этой области. Вы полностью способны создать свой собственный framework или WoW addon с функцией разблокировки и набором API, предоставляемым `MiniBot for WoW`, на чистом Lua.

Если вы всё ещё хотите строить свою логику поверх нашего framework разработки, вы всё ещё можете создать [Проект](#project) с основным фокусом на части [Пользовательских скриптов](#CUSTOM-SCRIPT). Обратите внимание, что все [Пользовательские скрипты](#CUSTOM-SCRIPT) загружаются в самом начале (в то же время, когда загружается MiniBot Development Framework), поэтому это довольно похоже на обычный lua файл WoW addon. Однако вы можете наслаждаться всеми преимуществами [Проекта](#project), включая настройки панели UI и шифрование с контролем авторизации!

Если вам совсем не нравится наш framework разработки, вы можете полностью создать свой собственный чистый WoW addon. И то, что предлагает `MiniBot` - это полнофункциональный разблокировщик, описанный ниже.

### РАЗБЛОКИРОВКА ЗАЩИЩЕННОГО WOW API

Вот [список](https://wow.gamepedia.com/Category:API_functions/Protected) всех защищенных официальных WoW API. Теперь с запущенным `MiniBot` все они свободны для использования без каких-либо проблем!

[Вернуться к началу](#home)

### УНИВЕРСАЛЬНЫЙ ID ОБЪЕКТА

[UnitId](https://wow.gamepedia.com/UnitId) - это специальный тип строкового аргумента, используемый многими WoW API. Он сильно ограничен игровой системой во многих случаях. Поэтому движок `MiniBot` расширяет новый тип универсального `ObjectId`, возвращаемого из серии пользовательских API, который представляет любой объект в игре и может быть передан как аргумент для любого параметра WoW API, который принимает [UnitId](https://wow.gamepedia.com/UnitId).

[Вернуться к началу](#home)

### ПОЛЬЗОВАТЕЛЬСКИЙ API

Актуальный пользовательский API MiniBot for WoW поддерживается [здесь](API.md).

[Вернуться к началу](#home)

### ПРОЕКТ, НЕЗАВИСИМЫЙ ОТ FRAMEWORK

MiniBot также позволяет создавать "независимые от framework" проекты, которые могут быть загружены MiniBot напрямую без AddOn framework. Такие проекты работают как чистый WoW AddOn, за исключением того, что:

1. Проект загружается как на экране входа, так и в мире.
2. Проект может быть зашифрован `MiniBot CLI`, чтобы воспользоваться преимуществами защиты исходного кода и контроля авторизации.
3. Каждый файл скрипта проекта (*.lua) получает два файловых аргумента. Один - это уникальная копия таблицы "wmbapi", а другой - уникальная таблица, содержащая неперехваченный WoW API (добавляется вручную). Поэтому лучше делать следующее в начале каждого файла скрипта проекта.
```lua
local wmbapi, wowapi = ...;
-- Вы можете быть уверены, что функции API в обеих таблицах не перехвачены/изменены.
```

Вам нужно вручную создать и отредактировать все файлы исходного кода в папке проекта, включая другой синтаксис "project.json" как файл манифеста Lua вместе с файлами Lua для загрузки. Простой проект relogger приведен [здесь](https://github.com/pierre-picard/minibot-wow/tree/master/examples/relogger) в качестве примера.

[Вернуться к началу](#home)


